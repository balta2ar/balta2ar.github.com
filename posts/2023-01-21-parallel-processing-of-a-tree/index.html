<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Parallel processing of a tree with several workers | Mostly Technical</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css></head><body><nav><ul class=menu><li><a href=/>Home</a></li><li><a href=/about/>About</a></li><li><a href=/categories/>Categories</a></li><li><a href=/tags/>Tags</a></li><li><a href=/index.xml>Subscribe</a></li></ul><hr></nav><div class=article-meta><h1><span class=title>Parallel processing of a tree with several workers</span></h1><h2 class=date>2023/01/21</h2><p class=terms>Tags: <a href=/tags/programming>programming</a> <a href=/tags/parallel>parallel</a> <a href=/tags/queue>queue</a> <a href=/tags/workers>workers</a></p></div><main><p>Every once in a while I need to write a script that traverses some structure,
typically a tree, that does something to every item, usually just prints it,
or makes a query that contains such item. It&rsquo;s fine to implement it
in a sequential manner if you have only few elements, but sometimes
it takes longer than I wish it took. Surprisingly often I found myself
implementing the same pattern, where I create a bunch of workers, and they
start traversing the structure all at the same time.</p><p>Let&rsquo;s start with the following imports:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> time <span style=color:#f92672>import</span> sleep, time
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> threading <span style=color:#f92672>import</span> Thread, Lock
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> collections <span style=color:#f92672>import</span> deque
</span></span></code></pre></div><p>Now let&rsquo;s define our node:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Node</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, data, children<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>data <span style=color:#f92672>=</span> data
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>children <span style=color:#f92672>=</span> [] <span style=color:#66d9ef>if</span> children <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span> <span style=color:#66d9ef>else</span> children
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add_child</span>(self, obj):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>children<span style=color:#f92672>.</span>append(obj)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_children</span>(self):
</span></span><span style=display:flex><span>        sleep(<span style=color:#ae81ff>0.1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>children
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@staticmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sample</span>():
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Node(<span style=color:#ae81ff>0</span>, [
</span></span><span style=display:flex><span>            Node(<span style=color:#ae81ff>1</span>, [
</span></span><span style=display:flex><span>                Node(<span style=color:#ae81ff>2</span>),
</span></span><span style=display:flex><span>                Node(<span style=color:#ae81ff>3</span>),
</span></span><span style=display:flex><span>            ]),
</span></span><span style=display:flex><span>            Node(<span style=color:#ae81ff>4</span>, [
</span></span><span style=display:flex><span>                Node(<span style=color:#ae81ff>5</span>),
</span></span><span style=display:flex><span>                Node(<span style=color:#ae81ff>6</span>),
</span></span><span style=display:flex><span>                Node(<span style=color:#ae81ff>7</span>),
</span></span><span style=display:flex><span>                Node(<span style=color:#ae81ff>8</span>, [
</span></span><span style=display:flex><span>                    Node(<span style=color:#ae81ff>9</span>),
</span></span><span style=display:flex><span>                    Node(<span style=color:#ae81ff>10</span>),
</span></span><span style=display:flex><span>                ]),
</span></span><span style=display:flex><span>            ]),
</span></span><span style=display:flex><span>        ])
</span></span></code></pre></div><p>To see the timing effect of our optimizations later I added <code>sleep(0.1)</code>
in <code>get_children</code> method.</p><p>Sequential traversal is just a simple recursion: we add current data
to the output and recursively go down to children, expanding on the result:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sequential</span>(node):
</span></span><span style=display:flex><span>    out <span style=color:#f92672>=</span> [node<span style=color:#f92672>.</span>data]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> child <span style=color:#f92672>in</span> node<span style=color:#f92672>.</span>get_children():
</span></span><span style=display:flex><span>        out <span style=color:#f92672>+=</span> sequential(child)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> out
</span></span></code></pre></div><p>When I measure this, I get the following timing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    node <span style=color:#f92672>=</span> Node<span style=color:#f92672>.</span>sample()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    t0 <span style=color:#f92672>=</span> time()
</span></span><span style=display:flex><span>    print(sorted(sequential(node)))
</span></span><span style=display:flex><span>    print(time() <span style=color:#f92672>-</span> t0)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</span></span><span style=display:flex><span>1.1016435623168945
</span></span></code></pre></div><p>The idea behind processing a tree in several workers is as follows:</p><ol><li>Start several workers</li><li>Wait for workers to complete processing</li></ol><p>Item #2 sounds a bit abstract, if you ask me. What is the condition
that says that we&rsquo;re done processing the tree?</p><p>Let&rsquo;s say we have a queue of items that should be processed. We start with
root and as we move along the tree, we add each node&rsquo;s children to
the queue. Can we say that we&rsquo;re done with processing if the queue is empty?</p><pre tabindex=0><code># queue = [node8]
w1: queue.take() is not None =&gt; node8.get_children() =&gt; sleep(0.1)
w2: queue.take() is None =&gt; terminate?
</code></pre><p>If we only check the size of the queue, we may end up falling prey to a bad
timing when one of the workers took an item from the queue, making the queue
empty, and while waiting for <code>get_children</code>, other workers woke up, requested
items from an empty queue, and then they decided to terminate.</p><p>What can help us is not only tracking the size of the queue, but if any items
that were taken out of the queue are still being processed. We will
use a helper class to abstract that away:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyQueue</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>lock <span style=color:#f92672>=</span> Lock()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>xs <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>running <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>add</span>(self, obj):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> self<span style=color:#f92672>.</span>lock:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>xs<span style=color:#f92672>.</span>append(obj)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>take</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> self<span style=color:#f92672>.</span>lock:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> len(self<span style=color:#f92672>.</span>xs) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>running <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>xs<span style=color:#f92672>.</span>pop(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>release</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> self<span style=color:#f92672>.</span>lock:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>running <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>empty</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>with</span> self<span style=color:#f92672>.</span>lock:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> len(self<span style=color:#f92672>.</span>xs) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> self<span style=color:#f92672>.</span>running <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>Given that we will access it from different threads, we need to protect
all operations with a lock. Another crucial part is <code>self.running</code> &ndash; when
we <code>take</code> item from a queue, we increment <code>self.running</code>, and when a worker
is done processing the item, even if there are no children, the worker
marks it as done with <code>release</code>.</p><p>To put all together:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>parallel</span>(root):
</span></span><span style=display:flex><span>    queue <span style=color:#f92672>=</span> MyQueue()
</span></span><span style=display:flex><span>    queue<span style=color:#f92672>.</span>add(root)
</span></span><span style=display:flex><span>    out <span style=color:#f92672>=</span> deque()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>work</span>():
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> <span style=color:#f92672>not</span> queue<span style=color:#f92672>.</span>empty():
</span></span><span style=display:flex><span>            node <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>take()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> node <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>                sleep(<span style=color:#ae81ff>0.05</span>) <span style=color:#75715e># waiting for more work to arrive</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>            out<span style=color:#f92672>.</span>append(node<span style=color:#f92672>.</span>data)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> child <span style=color:#f92672>in</span> node<span style=color:#f92672>.</span>get_children():
</span></span><span style=display:flex><span>                queue<span style=color:#f92672>.</span>add(child)
</span></span><span style=display:flex><span>            queue<span style=color:#f92672>.</span>release()
</span></span><span style=display:flex><span>    threads <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>):
</span></span><span style=display:flex><span>        t <span style=color:#f92672>=</span> Thread(target<span style=color:#f92672>=</span>work, args<span style=color:#f92672>=</span>())
</span></span><span style=display:flex><span>        t<span style=color:#f92672>.</span>start()
</span></span><span style=display:flex><span>        threads<span style=color:#f92672>.</span>append(t)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> t <span style=color:#f92672>in</span> threads:
</span></span><span style=display:flex><span>        t<span style=color:#f92672>.</span>join()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> list(out)
</span></span></code></pre></div><p>And now the running time is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    t0 <span style=color:#f92672>=</span> time()
</span></span><span style=display:flex><span>    print(sorted(parallel(node)))
</span></span><span style=display:flex><span>    print(time() <span style=color:#f92672>-</span> t0)
</span></span></code></pre></div><p>output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</span></span><span style=display:flex><span>0.4521338939666748
</span></span></code></pre></div><p>This approach is crude but fine for short scripts when you need to
quickly botch something up together. However, it might not be optimial
under load, especially this block is rather wasteful:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> node <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>    sleep(<span style=color:#ae81ff>0.05</span>) <span style=color:#75715e># waiting for more work to arrive</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>continue</span>
</span></span></code></pre></div></main><footer><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js></script>
<script>hljs.configure({languages:[]}),hljs.highlightAll()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-GKQQJJH05F"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-GKQQJJH05F",{anonymize_ip:!1})}</script><hr>© <a href=https://balta2ar.github.io>Yuri Bochkarev</a> 2009 &ndash; 2023 | <a href=https://github.com/balta2ar>Github</a>
| <a href=https://github.com/balta2ar/balta2ar.github.com/edit/main/content/posts/2023-01-21-parallel-processing-of-a-tree.md>Edit this page</a></footer></body></html>